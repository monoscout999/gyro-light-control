 ğŸ“‹ Informe de Autopsia TÃ©cnica: Proyecto gyro-light-control

  Analista: Gemini CLI
  Fecha: 20 de diciembre de 2025
  Estado del Proyecto: Funcional (Fase de TransiciÃ³n: EliminaciÃ³n de Fixtures)

  1. Inventario de Archivos Clave


  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Archivo                â”‚ PropÃ³sito Aparente                                                                     â”‚ Estado           â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ server.py              â”‚ Punto de entrada principal. Integra FastAPI, WebSocket y orquesta el flujo de datos.   â”‚ ğŸ› ï¸ En Desarrollo â”‚
  â”‚ math_engine.py         â”‚ Motor de cÃ¡lculo puro. ConversiÃ³n de Euler a 3D, intersecciÃ³n Ray-Box y calibraciÃ³n.   â”‚ âœ… Validado      â”‚
  â”‚ venue_manager.py       â”‚ GestiÃ³n del estado del espacio 3D (dimensiones, lÃ­mites, posiciÃ³n del usuario).        â”‚ âœ… Validado      â”‚
  â”‚ websocket_handler.py   â”‚ Capa de I/O de red. Maneja conexiones y suavizado de latencia mediante interpolaciÃ³n.  â”‚ ğŸ› ï¸ En Desarrollo â”‚
  â”‚ frontend/mobile.html   â”‚ Interfaz de captura de sensores. Captura deviceorientation y envÃ­a datos al servidor.  â”‚ âœ… Funcional     â”‚
  â”‚ frontend/js/scene3d.js â”‚ Visualizador 3D (Three.js). Refleja el estado calculado por el servidor en el cliente. â”‚ âœ… Funcional     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  2. Mapeo de Datos (Inputs/Outputs)

  Entradas (Inputs)
  Provienen principalmente del acelerÃ³metro/giroscopio del dispositivo mÃ³vil:
   * `alpha` (float): RotaciÃ³n en eje Z (0Â° a 360Â°). Representa el "yaw" o brÃºjula.
   * `beta` (float): RotaciÃ³n en eje X (-180Â° a 180Â°). Representa el "pitch" (inclinaciÃ³n adelante/atrÃ¡s).
   * `gamma` (float): RotaciÃ³n en eje Y (-90Â° a 90Â°). Representa el "roll" (inclinaciÃ³n lateral).
   * `timestamp` (int/float): Marca de tiempo en milisegundos para sincronizaciÃ³n y buffer de latencia.

  Salidas (Outputs)
  Enviadas desde el servidor hacia los visualizadores (Desktop/Mobile):
   * `pointer.intersection` (float[3]): Coordenadas [x, y, z] exactas donde el puntero virtual toca una superficie del recinto.
   * `pointer.direction` (float[3]): Vector normalizado [x, y, z] que indica la direcciÃ³n del puntero.
   * `sensor` (dict): Los datos originales del sensor (echo) para validaciÃ³n en el cliente.
   * `calibrated` (bool): Indicador de si el sistema estÃ¡ operando con un offset de calibraciÃ³n activo.

  Tipos de Datos Detectados
   * Arrays: numpy.ndarray en el backend para cÃ¡lculos vectoriales de alta eficiencia.
   * Estructuras: Diccionarios JSON para la comunicaciÃ³n WebSocket.
   * Coordenadas: Sistema Z-UP (X: Ancho, Y: Profundidad, Z: Altura).

  3. Bloques LÃ³gicos

  LÃ³gica Pura (Procesamiento/CÃ¡lculos)
   * `math_engine.euler_to_direction`: Transforma Ã¡ngulos Euler a un vector unitario en espacio 3D.
   * `math_engine.ray_box_intersection`: Algoritmo Slab Method para detectar colisiÃ³n entre el rayo del usuario y las "paredes" del recinto.
   * `math_engine.create_calibration_offset`: Genera matrices de rotaciÃ³n (Rodrigues' formula) para alinear sistemas de coordenadas.
   * `LatencyBuffer.get_interpolated`: Realiza interpolaciÃ³n lineal (con manejo de wrap-around para Ã¡ngulos) para predecir la posiciÃ³n entre paquetes
     de red.

  ImplementaciÃ³n I/O (Hardware/Red)
   * `WebSocketHandler`: Gestiona el ciclo de vida de las conexiones (Connect/Disconnect/Broadcast).
   * `DeviceOrientationEvent` (JS): API del navegador para acceder al hardware del giroscopio.
   * `server.lifespan`: Manejo del ciclo de vida de la aplicaciÃ³n FastAPI y recursos de red.

  4. Puntos de Acoplamiento (Fragilidades)

   * Acoplamiento en `server.py`: El archivo actÃºa como "pegamento" total. La lÃ³gica de calibraciÃ³n (Scalar Offset) reside directamente en la funciÃ³n
     process_sensor_data del servidor, mezclando lÃ³gica de negocio con el flujo de I/O.
   * DuplicaciÃ³n de Conocimiento Espacial: Tanto el backend (venue_manager.py) como el frontend (scene3d.js) deben "conocer" y validar de forma
     independiente el sistema de coordenadas (Z-UP) y las dimensiones del recinto. No existe un "Single Source of Truth" compartido dinÃ¡micamente mÃ¡s
     allÃ¡ de un mensaje inicial.
   * Dependencia de `numpy`: El motor matemÃ¡tico estÃ¡ fuertemente acoplado a las estructuras de datos de numpy, lo que dificulta una posible
     portabilidad a entornos sin esta librerÃ­a (aunque garantiza rendimiento).
   * LÃ³gica de CalibraciÃ³n HÃ­brida: Se detecta que math_engine.py tiene funciones para calibraciÃ³n matricial compleja, pero server.py utiliza
     actualmente una calibraciÃ³n escalar simplificada (alpha_offset). Existe cÃ³digo "muerto" o no utilizado en esta transiciÃ³n.

  ---
  ConclusiÃ³n del Analista: El sistema estÃ¡ bien modularizado en cuanto a responsabilidades (Math vs State vs I/O), pero la integraciÃ³n en server.py
  es rÃ­gida. La desapariciÃ³n del fixture_manager ha dejado espacio para simplificar el flujo, pero persisten restos de lÃ³gica matricial que no se
  estÃ¡n explotando.